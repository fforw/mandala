var Demo=function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=2)}([function(e,n,t){},,function(e,n,t){"use strict";t.r(n);t(0);Math.sqrt(5),Math.PI;var r,o,i,a,d,c={width:0,height:0};function f(e){o.uniform1f(i,e),o.uniform1f(a,c.width),o.uniform1f(d,c.height),o.drawElements(o.TRIANGLES,l.length,o.UNSIGNED_SHORT,0),requestAnimationFrame(f)}var h=[-1,1,0,-1,-1,0,1,-1,0,1,1,0],l=[3,2,1,3,1,0];function u(e){var n=-16&window.innerWidth,t=0|window.innerHeight;c.width=n,c.height=t,r.width=n,r.height=t,o.viewport(0,0,r.width,r.height)}window.onload=function(){r=document.getElementById("screen");var e=-16&window.innerWidth,n=0|window.innerHeight;c.width=e,c.height=n,r.width=e,r.height=n;var t=(o=r.getContext("webgl")).createBuffer();o.bindBuffer(o.ARRAY_BUFFER,t),o.bufferData(o.ARRAY_BUFFER,new Float32Array(h),o.STATIC_DRAW),o.bindBuffer(o.ARRAY_BUFFER,null);var v=o.createBuffer();o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,v),o.bufferData(o.ELEMENT_ARRAY_BUFFER,new Uint16Array(l),o.STATIC_DRAW),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null);var m=o.createShader(o.VERTEX_SHADER);o.shaderSource(m,"#define GLSLIFY 1\nattribute vec3 coordinates;\nvoid main(void) {\n    gl_Position = vec4(coordinates, 1.0);\n}\n"),o.compileShader(m);var x=o.createShader(o.FRAGMENT_SHADER);o.shaderSource(x,"precision mediump float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float width;\nuniform float height;\n\nconst float pi = 3.141592653589793;\nconst float tau = pi * 2.0;\nconst float hpi = pi * 0.5;\n\nconst float ninth = 1.0/9.0;\n\nfloat atan2(in float y, in float x)\n{\n    return abs(x) > abs(y) ? hpi - atan(x,y) : atan(y,x);\n}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nconst float interval = 50000.0;\nconst float third = 1.0/3.0;\nconst vec4 black = vec4(0,0,0,1);\nconst vec4 white = vec4(1,1,1,1);\n\nvoid main(void) {\n\n    float hw = width * 0.5;\n    float hh = width * 0.5;\n\n    float diagonal = sqrt(hw*hw+hh*hh);\n\n    float size = min(width, height);\n\n    float tx = (gl_FragCoord.x / size) * 2.0 - 1.0;\n    float ty = 1.0 - (gl_FragCoord.y / size) * 2.0;\n\n    if (width < height)\n    {\n        ty -= (height - width) / size;\n    }\n    else\n    {\n        tx -= (width - height) / size;\n    }\n\n    float a = fract(((atan2(ty,tx) + pi) / tau) + mod(time,  interval) / interval);\n\n    float a2 = mod(a, ninth) / ninth;\n\n    a2 = a2 < 0.5 ? a2 * 2.0 : 1.0 - (a2 - 0.5) * 2.0;\n\n    float d = sqrt( tx * tx + ty * ty);\n\n    d = d < 1.0 ? d: 1.0 - (d - 1.0);\n\n    vec3 color = vec3(a2,d,0);\n\n    gl_FragColor = vec4(abs(snoise(vec2(a2 * 0.7 + time * 0.0002,d * 6.0 - time * 0.0005))) > 0.25 /*&& a2 > 0.01 && a2 < 0.99 && mod(d, third) < third * 0.98*/ ? color: color * 0.25, 1);\n}\n\n"),o.compileShader(x);var s=!1;if(o.getShaderParameter(m,o.COMPILE_STATUS)||(console.error("Invalid vertex shader",o.getShaderInfoLog(m)),s=!0),o.getShaderParameter(x,o.COMPILE_STATUS)||(console.error("Invalid fragment shader",o.getShaderInfoLog(x)),s=!0),!s){var g=o.createProgram();if(o.attachShader(g,m),o.attachShader(g,x),o.linkProgram(g),o.getProgramParameter(g,o.LINK_STATUS)){i=o.getUniformLocation(g,"time"),a=o.getUniformLocation(g,"width"),d=o.getUniformLocation(g,"height"),o.useProgram(g),o.bindBuffer(o.ARRAY_BUFFER,t),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,v);var w=o.getAttribLocation(g,"coordinates");o.vertexAttribPointer(w,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(w),o.clearColor(0,0,0,1),o.enable(o.DEPTH_TEST),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT),o.viewport(0,0,r.width,r.height),window.addEventListener("resize",u,!0),requestAnimationFrame(f)}else console.error(o.getProgramInfoLog(g))}}}]);
//# sourceMappingURL=bundle-main-ab4c82ecbb037cb03157.js.map